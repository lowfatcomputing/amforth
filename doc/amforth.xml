<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd" [

<!ENTITY REFCARD SYSTEM "refcard.xml">

]>
<book>
    <bookinfo>
        <title>amforth: Forth for AVR ATmega microcontroller</title>
        <author>
            <personname>
                <firstname>Matthias</firstname>
                <surname>Trute</surname>
            </personname>
            <email>mtrute@users.sourceforge.net</email>
        </author>
        <pubdate>2008</pubdate>
        <copyright>
            <year>2007, 2008</year>
            <holder>Matthias Trute</holder>
        </copyright>
    </bookinfo>
    <toc />
    <preface>
        <title>Overview</title>
        <para>
            amforth is a Forth system for the AVR ATmega microcontroller
            family. It works on the controller itself and does not
            depend on any additional hard- or software. It places no
            restrictions on using external hardware.
        </para>
        <para>This document covers version 2.7</para>
        <para>
            amforth implements a large subset of the Forth standard
            ANS94. Most of the CORE and CORE EXT words and a varying
            number of words from the other word sets are implemented. It
            is very easy to extend or shrink the actual word list for a
            specific application by just editing the dictionary include
            files.
        </para>
        <para>
            The dictionary is located in the flash memory. The built-in
            compiler extends it directly.
        </para>
        <para>
            amforth provides full access to all interrupts. The
            interrupt handler routines are forth words.
        </para>
        <para>
            amforth is published under the GNU General Public License
            version 2.
        </para>
        <para>The name amforth has no special meaning.</para>
        <para>
            amforth is a new implementation. The first code was written
            in the summer of 2006. It is written "from scratch" using
            assembly language and forth itself. It does not have a
            direct relationship to any other forth system.
        </para>
        <para>
            The first lines of code were written with the AVR Studio and
            its simulator. Soon the switch to real hardware (an
            evaluation board) and to Linux based development was done.
        </para>
    </preface>
    <chapter id="FIRST_STEPS">
        <title>First Steps</title>
        <para>
            The first steps require a working ATmega microcontroller
            with an RS232 connection to an PC or a terminal like the
            <productname class="trade">VT100</productname>
            or similar hardware. A customization may change these
            requirements.
        </para>
        <sect1 id="UserInterface">
            <title>User Interface</title>
            <para>
                amforth has a simple user interface. Connect your system
                to a serial terminal (or a PC) and you get the forth
                prompt
                <prompt>></prompt>
                .
                <screen>
                    amforth 2.5 ATmega32
                    <prompt>></prompt>
                    <command>words</command>
                    cell+ cells abort abort" [char] ...
                    <prompt>></prompt>
                </screen>
            </para>
        </sect1>
    </chapter>
    <chapter id="HARDWARE">
        <title>Hardware</title>
        <sect1 id="HW_FUSES">
            <title>Fuses</title>
            <para>
                Amforth uses the self programming features of the
                ATmegas to extend the dictionary. It is ok to use the
                factory default settings plus (!) changes for the
                oscillator settings. It is recommended to use a higher
                CPU frequency to meet the timing requirements of the
                serial terminal.
            </para>
        </sect1>
    </chapter>
    <chapter id="Sources">
        <title>Source Organisation</title>
        <sect1 id="src_overview">
            <title>Overview</title>
            <para>
                The source code can be processed with both the AVR
                Studio and the linux avr assembler avra.
            </para>
            <para>
                amforth needs an assembler to generate the hex files for
                Flash and EEPROM. That does not mean that every word is
                actually written in assembly language however. Most of
                the words are written in forth itself, but are
                precompiled into assembly syntax. This solves btw the
                chicken-and-egg problem too: how to compile the compiler
                words.
            </para>
            <para>
                amforth consists of a great number of relatively small
                source files. Nearly all words are coded in their own
                source file. A number of files are organized with
                include files, called
                <filename>dict*.inc</filename>
                . Currently 3 such files exists:
                <filename>dict_minimum</filename>
                ,
                <filename>dict_high.inc</filename>
                and
                <filename>dict_compiler.inc</filename>
                .
            </para>
            <para>
                There are two additional files:
                <filename>amforth.asm</filename>
                and
                <filename>macros.asm</filename>
                . The first one is the master file and the only one the
                application needs to include. The file
                <filename>macros.asm</filename>
                contains some useful assembler macros that make the
                source code easier to read.
            </para>
        </sect1>
        <sect1 id="src_core_entry">
            <title>Core system</title>
            <para>
                The file
                <filename>amforth.asm</filename>
                is the core of amforth. Here is the startup code for the
                microcontroller, and the forth inner interpreter with
                the interrupt service routine. It includes the
                dictionary files.
            </para>
            <sect2 id="src_core_dict">
                <title>Dictionary files</title>
                <para>
                    The dictionary files have two tasks: First they
                    include the word definition files. Second, they
                    determine each word's location in the resulting
                    flash layout. The file dict_high.inc contains all
                    words for the NRWW flash section, Since the word
                    <command>I!</command>
                    cannot write to this address range, no new words can
                    be compiled to this section at runtime. Thus it is
                    advisable to include as many words as possible in
                    <filename>dict_high.inc</filename>
                    if the amount of writable dictionary space is an
                    issue.
                </para>
                <para>
                    A useful forth system needs at least the file
                    <filename>dict_minimum.inc</filename>
                    , which includes the serial IO and the forth
                    interpreter words.
                </para>
                <para>
                    An almost complete forth system with a compiler
                    needs the third include file:
                    <filename>dict_compiler.inc</filename>
                    .
                </para>
                <para>
                    There are a few words left out from the dictionary
                    lists. These words are either not always needed or
                    are some variants of existing words or simply cannot
                    be included in the core system due to size
                    limitations in the NRWW section with smaller
                    atmegas.
                </para>
            </sect2>
            <sect2>
                <title>Device Settings</title>
                <para>
                    Every Atmega has it own specific settings. They are
                    based on the official include files provided by
                    Atmel, which define the most important settings for
                    the serial IO port (which port and which
                    parameters), the interrupt vectors and some macros.
                </para>
                <para>
                    The last setting is a string with the device name in
                    clear text. This string is used within the word VER.
                </para>
            </sect2>
        </sect1>
        <sect1>
            <title>Application Code</title>
            <para>
                Every build of amforth needs an application. There are a
                few sample applications, which can be used either
                directly (such as the AVR Butterfly) or serve as a
                source for inspiration (template application).
            </para>
            <para>
                The structure is basically always the same. First the
                file macros.asm has to be included. After that some
                definitions need to done: The size of the Forth buffers,
                the CPU frequency, initial terminal settings etc. Then
                the device specific part needs to be included and as the
                last step the amforth core is included.
            </para>
            <para>
                For a comfortable development cycle the use of a make
                utility such as make itself is recommended. The
                assembler needs quite a few settings and the proper
                order of the include directories. The sample
                applications use the standard make, but others such as
                <command>ant</command>
                or
                <command>maven</command>
                can be used as well.
            </para>
        </sect1>
    </chapter>
    <chapter id="Architecture">
        <title>Architecture</title>
        <sect1 id="Architectur_Overview">
            <title>Overview</title>
            <para>
                amforth is a 16 bit Forth implementing the indirect
                threading model. The flash memory contains the whole
                dictionary. Some EEPROM cells are used to hold initial
                values and the dictionary pointers. The RAM contains
                buffers, variables and the stacks.
            </para>
            <para>
                The compiler is a classic compiler without any
                optimization support.
            </para>
            <para>
                amforth uses most of the CPU registers to hold vital
                data structures: The data stack pointer, the instruction
                pointer, the user pointer, and the Top-Of-Stack cell.
                The hardware stack is used as the return stack. Some
                registers are used for temporary data in primitives.
            </para>
        </sect1>
        <sect1 id="Architecture_VM">
            <title>CPU -- Forth VM Mapping</title>
            <para>
                The default Forth registers are mapped as follows
                <table>
                    <title>Register Mapping</title>
                    <tgroup cols="2">
                        <thead>
                            <row>
                                <entry>Forth Register</entry>
                                <entry>ATmega Register(s)</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry>W: Working Register</entry>
                                <entry>R26:R27</entry>
                            </row>
                            <row>
                                <entry>IP: Instruction Pointer</entry>
                                <entry>XH:XL</entry>
                            </row>
                            <row>
                                <entry>RSP: Return Stack Pointer</entry>
                                <entry>SPH:SPL</entry>
                            </row>
                            <row>
                                <entry>
                                    PSP: Parameter Stack Pointer
                                </entry>
                                <entry>YH:YL</entry>
                            </row>
                            <row>
                                <entry>UP: User Pointer</entry>
                                <entry>R4:R5</entry>
                            </row>
                            <row>
                                <entry>TOS: Top Of Stack</entry>
                                <entry>R6:R7</entry>
                            </row>
                            <row>
                                <entry>X: temporary register</entry>
                                <entry>ZH:ZL</entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </para>
            <para>
                In addition the register pair R0:R1 is used internally
                e.g. to hold the the result of multiply operations. The
                register pair R2:R3 is used as the zero value in many
                words. These registers cannot be used by user programs
                and should never be changed.
            </para>
            <para>
                The registers from R8 to R15 are currently unused. The
                registers R16 to R25 used as temporary registers and can
                be used freely within one module. They are overwritten
                by the primitives.
            </para>
            <para>
                The forth core uses the
                <code>T</code>
                bit in the machine status register SREG for signaling an
                interrupt.
            </para>
        </sect1>
        <sect1 id="Core_System">
            <title>Core System</title>
            <sect2 id="THREADMODEL">
                <title>Threading Model</title>
                <para>
                    amforth uses the classic indirect threaded variant
                    of forth.
                </para>
            </sect2>
            <sect2 id="INNER_INTERPRETER">
                <title>Inner Interpreter</title>
                <para>
                    For the indirect threading model an inner
                    interpreter will be needed. The interpreter core is
                    responsible for the interrupt handling too.
                </para>
                <sect3 id="II_EXECUTE">
                    <title>EXECUTE</title>
                    <para>
                        This operation reads the cell the IP currently
                        points to and uses the value as the destination
                        of a jump.
                    </para>
                </sect3>
                <sect3 id="II_NEXT">
                    <title>NEXT</title>
                    <para>
                        The NEXT routine is the core of the inner
                        interpreter. It performs two flash accesses, the
                        second one is accessed as EXECUTE.
                    </para>
                    <para>
                        The very first step in NEXT is to check whether
                        an interrupt needs to handled. It is done by
                        looking at the
                        <command>T</command>
                        flag in the machine status register. If it is
                        set, the code jumps to the interrupt handling
                        part. If the flag is cleared the following
                        normal NEXT routine runs.
                    </para>
                    <para>
                        <!-- 
                            (IP) -> W fetch memory pointed by IP into "W" register
                            ...W now holds address of the Code Field
                            
                            IP+cell -> IP advance IP, just like a program counter
                            
                            (W) -> X fetch memory pointed by W into "X" register
                            ...X now holds address of the machine code
                            
                            JP (X) jump to the address in the X register -->
                    </para>
                </sect3>
                <sect3 id="II_NEST">
                    <title>NEST</title>
                    <para>
                        NEST (aka DO_COLON) first pushes the IP (which
                        points to the next word to be executed when the
                        current word is done) to the return stack. It
                        then increments W by one flash cell, so that it
                        points to the body of the (colon) word, and sets
                        IP to point to same location. Then it continues
                        with NEXT, which begins executing the words in
                        the body of the colon word
                        <!--                   
                            PUSH IP onto the "return address stack"
                            
                            W+2 -> IP W still points to the Code Field, so W+2 is
                            the address of the Body! (Assuming a 2-byte address - -
                            other Forths may be different.)
                            
                            JUMP to interpreter ("NEXT")
                        -->
                    </para>
                </sect3>
                <sect3 id="II_UNNEST">
                    <title>UNNEST</title>
                    <para>
                        The code for UNNEST is the word
                        <command>EXIT</command>
                        in the dictionary. It pops the IP from the
                        return stack and jumps to NEXT.
                        <!-- 
                            POP IP from the "return address stack"
                            
                            JUMP to interpreter
                        -->
                    </para>
                </sect3>
                <sect3 id="II_DODOES">
                    <title>DO_DOES</title>
                    <para>
                        This code is the runtime that is used by the
                        code compiled by the forth word
                        <command>DOES</command>
                        . It it closely tied to the action performed by
                        the code compiled by DOES. That code pushed the
                        current address in the data field to the
                        returnstack and jumps to DO_DOES. DO_DOES gets
                        that address back, saves the current IP and sets
                        the forth IP to the address it got from the
                        stack. Finally it continues with NEXT.
                    </para>
                </sect3>
            </sect2>
            <sect2 id="STACKS">
                <title>Stacks</title>
                <sect3 id="DATASTACK">
                    <title>Data Stack</title>
                    <para>
                        The data stack uses the CPU register pair YH:YL
                        as its data pointer. The Top-Of-Stack element
                        (TOS) is in a register pair. Compared to a
                        straight forward implementation this approach
                        saves both code space and gives higher execution
                        speed (approx 10-20 %). Saving more stack
                        elements does not really provide a greater
                        benefit (much more code and only little speed
                        enhancements).
                    </para>
                    <para>
                        The data stack starts at a configurable distance
                        below the return stack (RAMEND) and grows
                        downward.
                    </para>
                </sect3>
                <sect3 id="RETURNSTACK">
                    <title>Return Stack</title>
                    <para>
                        The Return Stack is the hardware stack of the
                        controller. It is managed with push/pop
                        instructions. The return stack starts at RAMEND
                        und grows downward.
                    </para>
                </sect3>
            </sect2>
            <sect2 id="INTERRUPTS">
                <title>Interrupts</title>
                <para>
                    amforth routes the low level interrupts into the
                    forth inner interpreter. The inner interpreter
                    switches the execution to a predefined word if an
                    interrupt occurs. When that word finishes execution,
                    the interrupted word is continued. The interrupt
                    handlers are completely normal forth words without
                    any stack effect.
                </para>
                <para>
                    The processing of the interrupts takes two steps:
                    The first one is responsible for the low level part.
                    It is called whenever an interrupt occurs. The code
                    is the same for all interrupts. It takes the number
                    of the interrupt from its vector address and stores
                    this in a RAM cell. Then the low level ISR sets the
                    <command>T</command>
                    flag in the status register of the controller. The
                    inner interpreter checks this flaf every time it is
                    entered and if it is set it switches to interrupt
                    handling at forth level. This approach has a penalty
                    of 2 CPU cycles for checking and skipping the branch
                    instruction to the isr forth code.
                </para>
                <para>
                    The ISR at forth level is a RAM based table much
                    like the low level interrupt table of the execution
                    tokens associated with the interrupt number.
                </para>
                <para>
                    Interrupts from hardware sources (such as the usart)
                    may not work as expected. The reason is that the
                    interrupt source is not cleared within the generic
                    ISR. This leads to an immediate re-interrupt. There
                    is currently no solution but a custom ISR that
                    clears the interrupt source and calls the main ISR.
                    This code has to be run within the interrupt and
                    cannot be (easily) turned into forth code, since the
                    forth inner interpreter is not reentrant.
                    <!-- maybe run an forth
                        interpreter in background to handle interrupts? -->
                </para>
            </sect2>
            <sect2 id="MULTITASKING">
                <title>Multitasking</title>
                <para>
                    amforth does not implement multitasking directly. It
                    only provides the basic functions. Within the IO
                    words the deferred word
                    <command>PAUSE</command>
                    is called whenever possible. This word is
                    initialized to do nothing
                    <command>NOOP</command>
                    .
                </para>
            </sect2>
            <sect2 id="EXCEPTIONS">
                <title>Exception Handling</title>
                <para>
                    amforth implements the CATCH/THROW exception
                    handling. The outermost catch frame is located at
                    the interpreter level in the word QUIT. If an
                    exception with the value -1 or -2 is thrown, QUIT
                    will print a message and re-start itself. Other
                    values silently restart QUIT.
                </para>
            </sect2>
            <sect2 id="USERAREA">
                <title>User Area</title>
                <para>
                    The User Area is a special RAM based storage area.
                    It contains the USER variables and the User deferred
                    definitions. Access is based upon the value of the
                    user pointer UP. It can be changed with the word UP!
                    and read with UP@. The UP itself is stored in a
                    register pair.
                </para>
                <para>
                    The size of the user area is defined at compile time
                    in the device definition section. This may change in
                    future versions.
                </para>
                <para>
                    The User Area is used to provide task local
                    information. Without an active multitasker it
                    contains the starting values for the stackpointers,
                    the deferred words for terminal IO, the BASE
                    variable and the exception handler.
                </para>
                <para>
                    A multitasker can use the first 2 cells for own
                    purposes. In that situation the user area is/can be
                    seen as the task control block.
                </para>
            </sect2>
        </sect1>
        <sect1 id="Memory_Layout">
            <title>Memory Layout</title>
            <sect2 id="ML_FLASH">
                <title>Flash</title>
                <para>
                    The flash memory is divided into 5 sections. The
                    first section, starting at address 0, contains the
                    interrupt vector table for the low level interrupt
                    handling and a character string with the name of the
                    controller in plain text.
                </para>
                <para>
                    The next section is the initialization code block.
                    It is executed whenever the controller starts. The
                    code sets up the basic infrastructure for the forth
                    interpreter. This step is finished by calling the
                    forth interpreter with the word COLD as the entry
                    word.
                </para>
                <para>
                    The 3rd section contains the low level interrupt
                    handling routines. The interrupt handler is very
                    closely tied to the inner interpreter. It is located
                    near the first section to use the faster relative
                    jump instructions.
                </para>
                <para>
                    The 4th section is the first part of the dictionary.
                    Nearly all colon words are located here. New words
                    are appended to this section. This section is filled
                    with FFFF cells when flashing the controller
                    initially.
                </para>
                <para>
                    The last section is identical to the boot loader
                    section of the ATmegas. It is also known as the NRWW
                    area. Here is the heart of amforth: The inner
                    interpreter and most of the words coded in Assembly
                    language.
                </para>
                <para>
                    The reason for this split is a technical one: to
                    work with a dictionary in flash the controller needs
                    to write to the flash. The ATmega architecture
                    provides a mechanism called self-programming by
                    using a special instruction and a rather complex
                    algorithm. This instruction only works in the boot
                    loader/NRWW section. amforth uses this instruction
                    in the word I!. Due to the fact that the self
                    programming is a lot more then only a simple
                    instruction, amforth needs most of the forth core
                    system to achieve it. A side effect is that amforth
                    cannot co-exist with classic bootloaders. If a
                    particular boot loader provides an API to enable
                    applications call the flash write operation, amforth
                    can be restructured to use it. Currently only very
                    few and seldom used bootloaders exist that enable
                    this feature.
                </para>
                <para>
                    Atmegas can have more than 64 KB Flash. This
                    requires more than a 16 bit address, which is more
                    than the cell size. For one type of those bigger
                    atmegas there will be an solution with 16 bit cell
                    size: Atmega128 Controllers. They can use the whole
                    address range with an interpretation: The flash
                    addresses are in fact not byte addresses but word
                    addresses. Since amforth does not deal with bytes
                    but cells it is possible to use the whole address
                    range with a 16 bit cell. The Atmegas with 128
                    KBytes Flash operate slightly slower since the
                    address interpretation does need more code to access
                    the flash (both read and write).
                </para>
                <para>
                    The technique described above does not work for the
                    Atmega256x. These controllers definitely need a
                    bigger cell size: 17 bits (or more).
                </para>
                <sect3>
                    <title>Flash Write</title>
                    <para>
                        The word performing the actual flash write
                        operation is I! (i-store). This word takes the
                        value and the address of a single cell to be
                        written to flash from the data stack. The
                        address is a word address, not a byte address!
                    </para>
                    <para>
                        The flash write strategy follows Atmel's
                        appnotes. The first step is turning off all
                        interrupts. Then the affected flash page is read
                        into the flash page buffer. While doing the
                        copying a check is performed whether a flash
                        erase cycle is needed. The flash erase can be
                        avoided if no bit is turned from 0 to 1. Only if
                        a bit is switched from 0 to 1 must a flash page
                        erase operation be done. In the fourth step the
                        new flash data is written and the flash is set
                        back to normal operation and the interrupt flag
                        is restored.
                    </para>
                    <para>
                        This write strategy ensures that the flash has
                        minimal flash erase cycles while extending the
                        dictionary. In addition it keeps the forth
                        system simple since it does not need to deal
                        with page sizes or RAM based buffers for
                        dictionary operations.
                    </para>
                </sect3>
            </sect2>
            <sect2 id="ML_EEPROM">
                <title>EEPROM</title>
                <para>
                    The built-in EEPROM contains vital dictionary
                    pointer and other persistent data. They need only a
                    few EEPROM cells. The remaining space is available
                    for user programs. The easiest way to use EEPROM is
                    the use of forth VALUEs. There intended design
                    pattern (read often, write seldom) is like that for
                    the typical EEPROM usage.
                </para>
                <para>
                    Another use for EEPROM cells is to hold execution
                    tokens. The default system uses this for the turnkey
                    vector. This is an EEPROM variable that reads and
                    executes the XT at runtime. It is based on the
                    DEFER/IS standard. To define a deferred word in the
                    EEPROM use the Edefer defintion word. The standard
                    word IS is used to put a new XT into the vector.
                </para>
                <para>
                    Low level space management is done through the the
                    EDP variable. This is not a forth value but a EEPROM
                    based variable. To read the current value an e@
                    operation must be used, changes are written back
                    with e!. It contains the highest EEPROM address
                    currently allocated. The name is based on the DP
                    variable, which points to the highest dictionary
                    address.
                </para>
            </sect2>
            <sect2 id="ML_RAM">
                <title>RAM</title>
                <para>
                    The RAM address space is divided into three
                    sections: the first 32 addresses are the CPU
                    registers. Above come the IO registers and extended
                    IO registers and finally the RAM itself.
                </para>
                <para>
                    amforth needs a few (real) RAM locations for its
                    internal data structures. The biggest part are the
                    buffers for the terminal IO. RAM Memory is managed
                    by the words VARIABLE and ALLOT.
                </para>
                <para>
                    With amforth all three sections can be accessed
                    using their RAM addresses. That makes it quite easy
                    to work with words like
                    <command>C@</command>
                    . The word
                    <command>!</command>
                    implements a LSB byte order: The lower part of the
                    cell is stored at the lower address.
                </para>
                <para>
                    For the RAM there is the word
                    <command>Rdefer</command>
                    which implements a deferred word, placed in RAM. As
                    a special case there is the word
                    <command>Udefer</command>
                    , which sets up a deferred word in the user area. To
                    put an XT into them the word
                    <command>IS</command>
                    is used. This word is smart enough to distinguish
                    between the various xDefer definitions.
                </para>
            </sect2>
        </sect1>
    </chapter>
    <chapter id="Implementation">
        <title>Forth Implementation</title>
        <sect1 id="ANS">
            <title>ANS Words</title>
            <para>
                amforth implements most or all words from the ANS word
                sets CORE, CORE EXT, EXCEPTION and DOUBLE NUMBERS. The
                words from the word sets LOCALS, BLOCKS, FILE-ACCESS and
                FLOATING-POINT are dropped completly.
            </para>
            <sect2 id="ANS_CORE">
                <title>Core and Core EXT</title>
                <para>
                    From the CORE word set only the words >NUMBER, C,
                    CHAR+, CHAR, ENVIRONMENT?, EVALUATE, MOVE are
                    missing. From the CORE EXT the words C", COMPILE, ,
                    CONVERT, EXPECT, SPAN, PICK, RESTORE-INPUT, ROLL are
                    not implemented.
                </para>
                <para>
                    The following words have non-standard behavior
                </para>
                <para>
                    words created with
                    <command>:</command>
                    are immediately visible. An earlier definition with
                    the same name will never be accessible. Work around
                    may be done with
                    <command>DEFER</command>
                    /
                    <command>IS</command>
                    .
                </para>
                <para>
                    loop counters are checked on signed compares.
                </para>
            </sect2>
            <sect2 id="ANS_BLOCK">
                <title>Block</title>
                <para>
                    amforth does not currently support block related
                    words. Implementing them is on the roadmap.
                </para>
            </sect2>
            <sect2 id="ANS_DOUBLENUMBER">
                <title>Double Number</title>
                <para>
                    Double cell numbers do work as expected. Not all
                    words are implemented. Entering them directly using
                    the dot- notation does not work currently.
                </para>
            </sect2>
            <sect2 id="ANS_EXCEPTION">
                <title>Exception</title>
                <para>
                    Exceptions are fully supported. The words ABORT and
                    ABORT" use them internally.
                </para>
                <para>
                    The THROW codes -1, -2 and -13 work as specified.
                </para>
                <para>
                    The implementation is based upon a variable HANDLER
                    which holds the current return stack pointer
                    position. This variable is a USER variable.
                </para>
            </sect2>
            <sect2 id="ANS_FACILITY">
                <title>Facility</title>
                <para>
                    The basic system uses the KEY? and EMIT? words as
                    deferred words.
                </para>
                <para>
                    The word MS is implemented as the word 1MS which
                    busy waits almost exactly 1 millisecond. The
                    calculation is based upon the frequency specified at
                    compile time.
                </para>
                <para>
                    The words TIME&amp;DATE, EKEY, EKEY>CHAR are not
                    implemented.
                </para>
                <para>
                    To control a VT100 terminal the words AT-XY and PAGE
                    are written in forth code. They emit the ANSI
                    control codes according to the VT100 terminal codes.
                </para>
            </sect2>
            <sect2 id="ANS_FILEACCESS">
                <title>File Access</title>
                <para>
                    amforth does not have filesystem support. It does
                    not support any words from this word set.
                </para>
            </sect2>
            <sect2 id="ANS_FLOATINGPOINT">
                <title>Floating Point</title>
                <para>
                    amforth does not currently support floating point
                    numbers.
                </para>
            </sect2>
            <sect2 id="ANS_LOCALS">
                <title>Locals</title>
                <para>amforth does not currently support locals.</para>
            </sect2>
            <sect2 id="ANS_MEMORY">
                <title>Memory Allocation</title>
                <para>
                    amforth does not support the words from the memory
                    allocation word set.
                </para>
            </sect2>
            <sect2 id="ANS_PROGRAMMING">
                <title>Programming Tools</title>
                <para>
                    Variants of the words .S ? and DUMP are implemented
                    or can easily be done. The word SEE won't be
                    supported since amforth highly uses an optimization
                    strategy to strip forth headers whenever possible.
                    The other reason for dropping SEE is that amforth is
                    OpenSource software. If your vendor does not
                    disclose the full source, let me know. He violates
                    the GPL.
                </para>
                <para>
                    <command>STATE</command>
                    works as specified.
                </para>
                <para>
                    The word
                    <command>WORDS</command>
                    does not sort the word list and does not take care
                    of screen sizes.
                </para>
                <para>
                    The words
                    <command>CODE</command>
                    <command>;CODE</command>
                    and
                    <command>ASSEMBLER</command>
                    are not supported, amforth does not have an
                    assembler.
                </para>
                <para>
                    <command>CS-ROLL</command>
                    ,
                    <command>CS-PICK</command>
                    and
                    <command>AHEAD</command>
                    are not implemented. The compiler words operate with
                    the more traditional
                    <command>MARK</command>
                    /
                    <command>RESOLVE</command>
                    word pairs.
                </para>
                <para>
                    <command>FORGET</command>
                    is implemented but does not fully reset the
                    dictionary state. The better way is using
                    <command>MARKER</command>
                    .
                </para>
                <para>An EDITOR is not implemented.</para>
                <para>
                    <command>[IF]</command>
                    ,
                    <command>[ELSE]</command>
                    and
                    <command>[THEN]</command>
                    are not implemented.
                </para>
            </sect2>
            <sect2 id="ANS_SEARCH">
                <title>Search Order</title>
                <para>
                    amforth does not support word lists, so no words
                    from the search word set are implemented.
                </para>
            </sect2>
            <sect2 id="ANS_STRING">
                <title>Strings</title>
                <para>
                    <command>SLITERAL</command>
                    ,
                    <command>CMOVE></command>
                    and
                    <command>/STRING</command>
                    are implemented.
                </para>
                <para>
                    <command>-TRAILING</command>
                    ,
                    <command>BLANK</command>
                    ,
                    <command>CMOVE</command>
                    ,
                    <command>COMPARE</command>
                    and
                    <command>SEARCH</command>
                    are not implemented.
                </para>
            </sect2>
        </sect1>
        <sect1 id="AMFORTH">
            <title>amforth extensions</title>
            <sect2 id="AMFORTH_MCU">
                <title>MCU Access</title>
                <para>
                    amforth provides wrapper words for the
                    microcontroller words
                    <command>sleep</command>
                    and
                    <command>wdr</command>
                    (watch dog reset). To work properly, the MCU needs
                    more configuration. amforth itself does not call
                    these words.
                </para>
                <para>
                    Microcontrollers supporting the JTAG interface can
                    be programmed to turn JTAG off at runtime. Similiar
                    the watch dog timer can be disabled. Since both
                    actions require strict timing they need to be
                    implemented as primitives:
                    <command>-jtag</command>
                    and
                    <command>-wdt</command>
                    .
                </para>
            </sect2>
            <sect2 id="AMFORTH_MEMORY">
                <title>Memory</title>
                <para>
                    Atmega microcontroller have three different types of
                    memory. RAM, EEPROM and Flash. The words
                    <command>@</command>
                    and
                    <command>!</command>
                    work on the RAM address space (which includes IO
                    Ports and the CPU register), the words
                    <command>e@</command>
                    and
                    <command>e!</command>
                    operate on the EEPROM and
                    <command>i@</command>
                    and
                    <command>i!</command>
                    deal with the flash memory. All these words transfer
                    one cell (2 bytes) between the memory and the data
                    stack. The address is always the native address of
                    the target storage: byte-level for EEPROM and RAM,
                    word-level for flash. Therefore the flash addresses
                    64KWords or 128 KBytes address space.
                </para>
                <para>
                    External RAM shares the normal RAM address space
                    after initialization (which needs to be done within
                    the turnkey action). It is accessible without
                    further action.
                </para>
                <para>
                    For RAM only there is the special word pair
                    <command>c@</command>
                    /
                    <command>c!</command>
                    which uses the lower byte of the Top-Of-Stack at
                    transfer. The upper byte is either ignored or set to
                    0 (zero).
                </para>
                <para>
                    All other types of external memory need special
                    handling, which may be masked with the block word
                    set.
                </para>
            </sect2>
            <sect2 id="AMFORTH_IO">
                <title>Input Output</title>
                <para>
                    amforth uses simple terminal io. A serial console is
                    used. All IO is based upon the standard words
                    <command>EMIT</command>
                    /
                    <command>EMIT?</command>
                    and
                    <command>KEY</command>
                    /
                    <command>KEY?</command>
                    . In addition the word
                    <command>/KEY</command>
                    is used to signal the sender to stop. All these
                    words are deferred words in the USER area and can be
                    changed with the
                    <command>IS</command>
                    command.
                </para>
                <para>
                    The predefined words use an interrupt driven IO with
                    an buffer for input and output. They do not
                    implement a handshake procedure (XON/XOFF or
                    CTS/RTS). The default terminal device is USART0 (if
                    more than one USART port is available).
                </para>
                <para>
                    The basic words include a call of the
                    <command>PAUSE</command>
                    command to enable the use of multitasking.
                </para>
                <para>
                    Other IO depend on the hardware connected to the
                    microcontroller. Code exists to use LCD and TV
                    devices. CAN, USB or I2C are possible as well.
                    Another use of the redirect feature is the
                    following: consider some input data in external
                    EEPROM (or SD-Cards). To read it, the words
                    <command>KEY</command>
                    and
                    <command>KEY?</command>
                    are redirected to fetch the data from them.
                </para>
            </sect2>
            <sect2 id="AMFORTH_STRING">
                <title>Strings</title>
                <para>
                    Strings can be stored in two areas: RAM and FLASH.
                    It is not possible to distinguish between the
                    storage areas based on the addresses found on the
                    data stack, it's up to the developer to keep track.
                </para>
                <para>
                    Strings are usually stored as counted strings.
                    Strings in flash are compressed: two consecutive
                    bytes are placed into one flash cell. The standard
                    word
                    <command>S"</command>
                    copies the string from the RAM into flash using the
                    word
                    <command>S,</command>
                    .
                </para>
            </sect2>
        </sect1>
    </chapter>
    <chapter id="Library">
        <title>Library</title>
        <para>
            Amforth does not have a formal library concept. Amforth has
            a lot of forth code that can be seen as a library of words
            and commands.
        </para>
        <sect1 id="Hardware">
            <title>Hardware Access</title>
            <para>
                In the
                <filename>device/</filename>
                subdirectory are the controller specific register
                definitions. They are taken directly from the appnotes
                from atmel. The register names are all uppercase. It is
                recommended to extract only the needed definitions since
                the whole list occupy flash space.
            </para>
        </sect1>
        <sect1 id="Modules">
            <title>Software Modules</title>
            <sect2 id="Multitasking">
                <title>Multitasking</title>
                <para>
                    The Library contains a cooperative multitasker in
                    the file
                    <filename>multitask.frt</filename>
                    . It defines a command
                    <command>multitaskpause</command>
                    which can assigned to
                    <command>pause</command>
                    .
                </para>
                <para>
                    The multitasker has the following commands
                    <variablelist>
                        <varlistentry>
                            <term>
                                <cmdsynopsis>
                                    <command>onlytask</command>
                                    <arg choice="plain">(--)</arg>
                                </cmdsynopsis>
                            </term>
                            <listitem>
                                <para>
                                    Initialize the task system. The
                                    current task is placed as the only
                                    task in the task list.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term>
                                <cmdsynopsis>
                                    <command>alsotask</command>
                                    <arg choice="plain">(tid --)</arg>
                                </cmdsynopsis>
                            </term>
                            <listitem>
                                <para>
                                    Append a newly created task to the
                                    task list. A running multitasker is
                                    temporarily stopped. Make sure that
                                    the status of the task is sleep.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term>
                                <cmdsynopsis>
                                    <command>task</command>
                                    <arg choice="plain">
                                        ( dstacksize rstacksize -- tid )
                                    </arg>
                                </cmdsynopsis>
                            </term>
                            <listitem>
                                <para>
                                    Allocate RAM for the task control
                                    block (aka user area) and the two
                                    stacks. Initializes the whole user
                                    area to direct IO to the serial
                                    line. The task has still no code
                                    associated and is not inserted to
                                    the task list.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term>
                                <cmdsynopsis>
                                    <command>task-sleep</command>
                                    <arg choice="plain">( tid --)</arg>
                                </cmdsynopsis>
                            </term>
                            <listitem>
                                <para>
                                    Let the (other) task sleep. The task
                                    switcher skips the task on the next
                                    round. When a task executes this
                                    command for itself, the task
                                    continues until the next call of
                                    pause.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term>
                                <cmdsynopsis>
                                    <command>task-awake</command>
                                    <arg choice="plain">( tid --)</arg>
                                </cmdsynopsis>
                            </term>
                            <listitem>
                                <para>
                                    The task is put into runnable mode.
                                    It is not activated immediately.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term>
                                <cmdsynopsis>
                                    <command>activate</command>
                                    <arg choice="plain">( tid --)</arg>
                                </cmdsynopsis>
                            </term>
                            <listitem>
                                <para>
                                    Skip all of the remaining code in
                                    the current colon word and continue
                                    the skipped code as a task.
                                </para>
                            </listitem>
                        </varlistentry>
                    </variablelist>
                </para>
                <para>
                    It is possible to use a timer interrupt to call the
                    command
                    <command>pause</command>
                    and turn the cooperative multitasker into a
                    preemptive one. The latency is in the worst case
                    that of the longest running uninterruptable forth
                    commands:
                    <command>1ms</command>
                    ,
                    <command>e!</command>
                    and
                    <command>i!</command>
                    . For a preemptive task switcher a lot more tools
                    like semaphores may be needed.
                </para>
            </sect2>
        </sect1>
    </chapter>
    <chapter id="Tools">
        <title>Tools</title>
        <sect1 id="Tools_host">
            <title>Host</title>
            <para>
                There a few number of tools on the hostside (PC) that
                are specifically written to support amforth. They are
                written in script languages like perl and python and
                should work on all major operating systems.
            </para>
            <sect2>
                <title>Documentation</title>
                <para>
                    The tool
                    <command>makerefcard</command>
                    reads the assembly files from the
                    <filename>words</filename>
                    subdirectory and creates a reference card. The
                    resulting LaTeX file needs to be processed with
                    latex to generate a nice looking overview of all
                    words available in the amforth core system.
                </para>
                <para>
                    The command
                    <command>make-htmlwords</command>
                    creates the linked overview of all words on the
                    amforth homepage.
                </para>
            </sect2>
            <sect2 id="TOOLS_UPLOAD">
                <title>Uploader</title>
                <para>
                    To transfer forth code to the microcontroller some
                    precautions need to taken. During a flash write
                    operation all interrupts are turned off. This may
                    lead to lost characters on the serial line. One
                    solution is to send very slowly and hope that the
                    receiver gets all characters. The program
                    <command>ascii-xfer</command>
                    can do the job:
                    <cmdsynopsis>
                        <command>ascii-xfr</command>
                        <arg choice="plain">-s</arg>
                        <arg choice="plain">-c $delay_char</arg>
                        <arg choice="plain">-l $delay_line</arg>
                        <arg choice="plain">$file</arg>
                        <arg choice="plain">> $tty</arg>
                    </cmdsynopsis>
                    This works but the upload of longer files needs a
                    very long time.
                </para>
                <para>
                    Another solution is
                    <command>amforth-upload.py</command>
                    . It was initially created by user
                    <ulink url="http://pix.test.at/">
                        <citetitle>pix</citetitle>
                    </ulink>
                    . His algorithm checks for the echo of every
                    character sent to the controller. At line ends the
                    uploader waits for the ok prompt to continue with
                    the next line.
                </para>
                <para>
                    This algorithm works very fast without the risk of
                    lost characters. An extension of this script
                    provides limited library support. In the source
                    files a command
                    <cmdsynopsis>
                        <command>#include</command>
                        <arg choice="plain">filename</arg>
                    </cmdsynopsis>
                    is used to upload the content of
                    <filename>filename</filename>
                    instead of the two words. The sources will only work
                    with this uploader utility, others will trigger the
                    "word-not-found" exception on the microcontroller
                    unless they recognize the #include syntax (similar
                    to the c preprocessor).
                </para>
            </sect2>
        </sect1>
    </chapter>
    <chapter id="FINAL_REMARKS">
        <title>Final Remarks</title>
        <sect1 id="ANS94_WORDS">
            <title>More ANS94 Words</title>
            <para>
                There are a few missing words from the standard CORE
                word set. Many of them are related with string
                parameters, like
                <code>evaluate</code>
                and
                <code>environment?</code>
                . The difficulty arises from the fact, that the storage
                location of a string cannot be determined by simply
                lookaing at the address. A solution may be a state smart
                implementation with some helper words. If running
                interactivly, these words may use RAM addresses, if
                called within a compiled word they use flash addresses.
                Not really smart however..
            </para>
            <para>
                Support for Blocks may be useful. It is not trivial to
                implement a standard 1KB block buffer on an Atmega with
                only 1KB RAM. It can be useful to deploy block sizes
                smaller than 1KB to match the native block sizes of the
                attached storage devices: serial EEPROM have e.g. 64
                bytes, SD-Cards have 512 bytes. Some rather simple code
                can be used from the library for I2C/TWI EEPROM modules
                with native block sizes.
            </para>
        </sect1>
        <sect1 id="MoreController">
            <title>More Controller Types</title>
            <para>
                amforth can run on the whole range of Atmegas. The only
                limiting factor is the flash size: amforth needs 7 KB
                for itself and can address 128 KB. The ATmega256x may be
                supported with a change in the cell size from 2 to 3
                bytes. The other possible devices are the XMega MCU,
                that Atmel may publish in the near future. ATtiny
                devices are not supported since they lack both flash
                size and a few instructions that amforth uses.
            </para>
        </sect1>
        <sect1 id="Contributors">
            <title>Contributors</title>
            <para>
                amforth would not be the system it now is without the
                feedback and help from its users. I would like to thank
                all of them. The following people made an outstanding
                work to improve amforth (in no particular order): Milan
                Horkel, Ullrich Hoffmann, Michael Kalus, Karl Lunt,
                Bruce Wolk. But there are many more that helped by
                simply asking how to do some tasks.
            </para>
        </sect1>
        <sect1 id="SUPPORT">
            <title>Support</title>
            <para>
                Amforth is not a commercial grade software. I hesitate
                to call it a product. Since you get all the source code
                for system, you should be able to solve all problems
                youself. On the other hand I'm interested in any use of
                amforth and want to know what you're doing with it. If
                you find anything strange or faulty don't hesitate to
                mail it to the
                <ulink
                    url="mailto:amforth-devel@lists.sourceforge.net">
                    mailing list
                </ulink>.
            </para>
        </sect1>
    </chapter>
    <!--  &REFCARD; -->
</book>
