<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [

<!ENTITY REFCARD SYSTEM "refcard.xml">

]>
<book>
	<bookinfo>
		<title>amforth 3.2</title>
		<subtitle>Technical Documentation</subtitle>
		<author>
			<personname>
				<firstname>Matthias</firstname>
				<surname>Trute</surname>
			</personname>
			<email>mtrute@users.sourceforge.net
			</email>
		</author>
		<pubdate>2008</pubdate>
		<copyright>
			<year>2007, 2008</year>
			<holder>Matthias Trute</holder>
		</copyright>
	</bookinfo>
	<toc />
	<preface>
		<title>Overview</title>
		<para>Amforth is a Forth system for the AVR ATmega microcontroller
			family. It works on the controller itself and does not depend on any
			additional hard- or software. It places no restrictions on using
			external hardware.</para>
		<para>Amforth implements a large subset of the Forth standard ANS94.
			Most of the CORE and CORE EXT words and a varying number of words
			from the other word sets are implemented. It is very easy to extend
			or shrink the actual word list for a specific application by just
			editing the dictionary include files.</para>
		<para> The dictionary is located in the flash memory. The built-in
			compiler extends it directly.</para>
		<para> amforth provides full access to all interrupts. The interrupt
			handler routines can be code or forth words.</para>
		<para>Amforth is published under the GNU General Public License
			version 2.</para>
		<para>The name amforth has no special meaning.</para>
		<para>Amforth is a new implementation. The first code was written in
			the summer of 2006. It is written "from scratch" using assembly
			language and forth itself. It does not have a direct relationship to
			any other forth system.</para>
	</preface>
	<chapter id="FIRST_STEPS">
		<title>First Steps</title>
		<para>
			The first steps require an ATmega microcontroller with an
			RS232 connection to an PC or a terminal like the
			<productname class="trade">VT100</productname>
			or similar hardware. A customization may change these requirements.
		</para>
		<sect1 id="UserInterface">
			<title>User Interface</title>
			<para>
				amforth has a simple user interface. Connect your system to a serial
				terminal (or a PC) and you get the forth prompt
				<prompt>></prompt>
				.
				<screen>
					amforth 3.2 ATmega32
					<prompt>></prompt>
					<command>words</command>
					d2/ s>d up! up@ 0 1ms cmove cmove> i! i@ unloop i sp! ...
					<prompt>></prompt>
				</screen>
			</para>
		</sect1>
	</chapter>
	<chapter id="Hardware">
		<title>Hardware</title>
		<sect1 id="Controller">
			<title>Controller</title>
			<para>amforth is designed to run on AVR Atmega
				microcontrollers. It requires
				ca 7KB flash memory for the basic
				system and can address 128KB of
				flash memory.
		</para>
			<para>The ATtiny microcontrollers and a a few ATmega types lack
				the minimum
				flash capacity. The ATtiny's some machine instructions as
				well. </para>

			<para>Microcontrollers with more than 128KB flash
				memory are currently not
				usable.</para>

		</sect1>
		<sect1 id="Bootloader">
			<title>Bootloader Support</title>
			<para>Most bootloaders will not work with amforth since they do
				not provide an
				application programming interface to rewrite a single
				flash cell. The default
				setup will thus replace any bootloader found
				with some core
				routines.</para>
			<para>
				It is possible to change the word
				<code>i!</code>
				to use an API and work
				with existing bootloaders.
			</para>
		</sect1>
		<sect1 id="Fuses">
			<title>Fuses</title>
			<para> Amforth uses the self programming feature of the ATmega
				microcontrollers to work with the dictionary. It is ok to use the
				factory default settings plus the changes for the oscillator
				settings. It is recommended to use a higher CPU frequency to meet
				the timing requirements of the serial terminal.</para>
		</sect1>
	</chapter>
	<chapter id="Sources">
		<title>Source Organisation</title>
		<sect1 id="src_overview">
			<title>Overview</title>
			<para> amforth is written using the standard Atmel AVR 8 bit assembly
				language. That does not mean that every word is actually written in
				assembly language however. Most of the words are written in forth
				itself, but are precompiled into the assembler syntax. This solves
				the chicken-and-egg problem: how to compile the compiler words.
			</para>
			<para> The source code can be processed with both the AVR Studio and
				the linux avr assembler avra.</para>
			<para>
				amforth consists of a great number of small source files. Nearly all
				words are coded in their own source files. These files are organized
				with include files, named after the pattern
				<filename>dict*.inc</filename>
				. Currently 4 such files exists:
				<filename>dict_minimum</filename>
				,
				<filename>dict_mcu</filename>
				,
				<filename>dict_core.inc</filename>
				and
				<filename>dict_compiler.inc</filename>
				. The order in which the files are included defines the search order
				and there location within the flash memory. Most words can be moved
				from one include file to another to optimize the flash usage.
			</para>
			<para>
				There are two additional files:
				<filename>amforth.asm</filename>
				and
				<filename>macros.asm</filename>
				. The first one is the master file and the only one the application
				needs to include. The file
				<filename>macros.asm</filename>
				contains some useful assembler macros that make the source code
				easier to read.
			</para>
		</sect1>
		<sect1 id="src_core_entry">
			<title>Core system</title>
			<para>
				The file
				<filename>amforth.asm</filename>
				is the core of amforth. Here is the startup code for the
				microcontroller, and the forth inner interpreter with the interrupt
				service routine. It includes the dictionary files.
			</para>
			<sect2 id="src_core_dict">
				<title>Dictionary files</title>
				<para>
					The dictionary files have two tasks: First they include the word
					definition files. Second, they determine each word's location in
					the resulting flash layout. The file
					<filename>dict_core.inc</filename>
					contains all words for the NRWW flash section, Since the word
					<command>I!</command>
					cannot write to this address range, no new words can be compiled to
					this section at runtime. Thus it is advisable to include as many
					words as possible in
					<filename>dict_core.inc</filename>
					if the amount of writable dictionary space is an issue.
				</para>
				<para>
					A useful forth system needs in addition to the above at least the
					file
					<filename>dict_minimum.inc</filename>
					, which includes the forth interpreter words.
				</para>
				<para>
					An almost complete forth system with a compiler gives the third
					include file:
					<filename>dict_compiler.inc</filename>
					.
				</para>
				<para>
					Some words have their source files within the
					<filename>core/words</filename>
					directory but have to be included via the
					<filename>dict_appl.inc</filename>
					file. These words define the hardware dependecies to access the
					amforth system. The serial line terminal is an example.
				</para>
				<para> There are a few words left out from the dictionary lists.
					These words are either not always needed or are some variants of
					existing words or simply cannot be included in the core system due
					to size limitations in the NRWW section with smaller atmegas. They
					are usually included by the application specific include file(s).
				</para>
			</sect2>
			<sect2>
				<title>Device Settings</title>
				<para> Every Atmega has its own specific settings. They are based on
					the official include files provided by Atmel and define the
					important settings for the serial IO port (which port and which
					parameters), the interrupt vectors and some macros.</para>
				<para>Adapting another ATmega microcontroller is as easy as
					copy and edit an existing file from a similiar type.</para>
				<para>
					The last definition is a string with the device name in clear text.
					This string is used within the word
					<command>VER</command>
					.
				</para>
			</sect2>
		</sect1>
		<sect1>
			<title>Application Code</title>
			<para> Every build of amforth needs an application. There are a few
				sample applications, which can be used either directly (AVR
				Butterfly) or serve as a source for inspiration (template
				application).</para>
			<para>
				The structure is basically always the same. First the file
				<filename>macros.asm</filename>
				has to be included. After that some definitions need to done: The
				size of the Forth buffers, the CPU frequency, initial terminal
				settings etc. Then the device specific part needs to be included and
				as the last step the amforth core is included.
			</para>
			<para>
				For a comfortable development cycle the use of a build utility such
				as
				<command>make</command>
				or
				<command>ant</command>
				is recommended. The assembler needs a few settings and the proper
				order of the include directories.
			</para>
		</sect1>
	</chapter>
	<chapter id="Architecture">
		<title>Architecture</title>
		<sect1 id="Architectur_Overview">
			<title>Overview</title>
			<para> amforth is a 16 bit Forth implementing the indirect threading
				model. The flash memory contains the whole dictionary. A few EEPROM
				cells are used to hold initial values and the dictionary pointers.
				The RAM contains buffers, variables and the stacks.</para>
			<para> The compiler is a classic compiler without any optimization
				support.</para>
			<para> amforth uses most of the CPU registers to hold vital data: The
				data stack pointer, the instruction pointer, the user pointer, and
				the Top-Of-Stack cell. The hardware stack is used as the return
				stack. Some registers are used for temporary data in primitives.
			</para>
		</sect1>
		<sect1 id="Architecture_VM">
			<title>CPU -- Forth VM Mapping</title>
			<para>
				The default Forth registers are mapped as follows
				<table>
					<title>Register Mapping</title>
					<tgroup cols="2">
						<thead>
							<row>
								<entry>Forth Register</entry>
								<entry>ATmega Register(s)</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry>W: Working Register</entry>
								<entry>R24:R25</entry>
							</row>
							<row>
								<entry>IP: Instruction Pointer</entry>
								<entry>XH:XL (R27:R26)</entry>
							</row>
							<row>
								<entry>RSP: Return Stack Pointer</entry>
								<entry>SPH:SPL</entry>
							</row>
							<row>
								<entry> PSP: Parameter Stack Pointer</entry>
								<entry>YH:YL (R29:R28)</entry>
							</row>
							<row>
								<entry>UP: User Pointer</entry>
								<entry>R4:R5</entry>
							</row>
							<row>
								<entry>TOS: Top Of Stack</entry>
								<entry>R22:R23</entry>
							</row>
							<row>
								<entry>X: temporary (scratch pad) register</entry>
								<entry>ZH:ZL (R31:R30)</entry>
							</row>
						</tbody>
					</tgroup>
				</table>
				<table>
					<title>Extended Forth VM Register Mapping</title>
					<tgroup cols="2">
						<thead>
							<row>
								<entry>Forth Register</entry>
								<entry>ATmega Register(s)</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry>A: Index and Scratch Register</entry>
								<entry>R6:R7</entry>
							</row>
							<row>
								<entry>B: Index and Scratch Register</entry>
								<entry>R8:R9</entry>
							</row>
						</tbody>
					</tgroup>
				</table>
			</para>
			<para> In addition the register pair R0:R1 is used internally e.g. to
				hold the the result of multiply operations. The register pair R2:R3
				is used as the zero value in many words. These registers must never
				be changed.</para>
			<para> The registers from R10 to R13 are currently unused, but may be
				used for the VM extended registers X and Y sometimes. The
				registers
				R14 to R21
				are used as temporary registers and can be used
				freely
				within one
				module as temp0 to temp7.</para>
			<para>
				The forth core uses the
				<code>T</code>
				bit in the machine status register SREG for signalling an interrupt.
			</para>
		</sect1>
		<sect1 id="Core_System">
			<title>Core System</title>
			<sect2 id="THREADMODEL">
				<title>Threading Model</title>
				<para> amforth implements the classic indirect threaded variant of
					forth.</para>
			</sect2>
			<sect2 id="INNER_INTERPRETER">
				<title>Inner Interpreter</title>
				<para> For the indirect threading model an inner interpreter is
					needed. The inner interpreter does the interrupt handling too.
				</para>
				<sect3 id="II_EXECUTE">
					<title>EXECUTE</title>
					<para> This operation reads the cell the IP currently points to and
						uses the value read as the destination of a branch. This EXECUTE
						is not the forth word EXECUTE. The forth EXECUTE sets the IP from
						the data stack TOS element.</para>
				</sect3>
				<sect3 id="II_NEXT">
					<title>NEXT</title>
					<para> The NEXT routine is the core of the inner interpreter. It
						consists of 4 steps which are executed for every forth word.
					</para>
					<para>
						The first step in NEXT is to check whether an interrupt needs to
						be handled. It is done by looking at the
						<command>T</command>
						flag in the machine status register. If it is set, the code jumps
						to the interrupt handling part. If the flag is cleared the
						following normal NEXT routine runs.
					</para>
					<para> The next step is to read the cell the IP points to and
						stores this value in the W register. For a COLON word W contains
						the address of the code field.</para>
					<para> The 3rd step is to increase the IP register by 1.</para>
					<para> The 4th step is to read the content of the cell the W
						register points to. The value is stored in the scratch pad
						register X. The data in X is the address of the machine code to be
						executed in the last step.</para>
					<para> This last step finally jumps to the machine code pointed to
						by the X scratch pad register.</para>
				</sect3>
				<sect3 id="II_NEST">
					<title>NEST</title>
					<para> NEST (aka DO_COLON) first pushes the IP (which points to the
						next word to be executed when the current word is done) to the
						return stack. It then increments W by one flash cell, so that it
						points to the body of the (colon) word, and sets IP to point to
						that value. Then it continues with NEXT, which begins executing
						the words in the body of the (parent) colon word.</para>
				</sect3>
				<sect3 id="II_UNNEST">
					<title>UNNEST</title>
					<para>
						The code for UNNEST is the forth word
						<command>EXIT</command>
						in the dictionary. It reads the IP from the return stack and jumps
						to NEXT. The return stack pointer is incremented by 2 (1 flash
						cell).
					</para>
				</sect3>
				<sect3 id="II_DODOES">
					<title>DO_DOES</title>
					<para>
						This code is the runtime part of the forth word
						<command>DOES</command>
						. It pushes the current address of the MCU IP register onto the
						returnstack and jumps to DO_DOES. DO_DOES gets that address back,
						saves the current IP and sets the forth IP to the address it got
						from the stack. Finally it continues with NEXT.
					</para>
				</sect3>
			</sect2>
			<sect2 id="STACKS">
				<title>Stacks</title>
				<sect3 id="DATASTACK">
					<title>Data Stack</title>
					<para> The data stack uses the CPU register pair YH:YL as its data
						pointer. The Top-Of-Stack element (TOS) is in a register pair.
						Compared to a straight forward implementation this approach saves
						code space and gives higher execution speed (approx 10-20%). Saving even more stack
                        elements does not really provide a greater
                        benefit (much more code and only little speed
                        enhancements).
                    </para>
                    <para>
                        The data stack starts at a configurable distance
                        below the return stack (RAMEND) and grows
                        downward.
                    </para>
                </sect3>
                <sect3 id="RETURNSTACK">
                    <title>Return Stack</title>
                    <para>
                        The Return Stack is the hardware stack of the
                        controller. It is managed with push/pop
                        assembler instructions. The default return stack
                        starts at RAMEND und grows downward.
                    </para>
                </sect3>
            </sect2>
            <sect2 id="INTERRUPTS">
                <title>Interrupts</title>
                <para>
                    amforth routes the low level interrupts into the
                    forth inner interpreter. The inner interpreter
                    switches the execution to a predefined word if an
                    interrupt occurs. When that word finishes execution,
                    the interrupted word is continued. The interrupt
                    handlers are completly normal forth colon words
                    without any stack effect.
                </para>
                <para>
                    The processing of the interrupts takes two steps:
                    The first one is responsible for the low level part.
                    It is called whenever an interrupt occurs. The code
                    is the same for all interrupts. It takes the number
                    of the interrupt from its vector address and stores
                    this in a RAM cell. Then the low level ISR sets the
                    <command>T</command>
                    flag in the status register of the controller. The
                    inner interpreter checks this flag every time it is
                    entered and, if it is set, it switches to interrupt
                    handling at forth level. This approach has a penalty
                    of 2 CPU cycles for checking and skipping the branch
                    instruction to the isr forth code if no interrupt
                    occured.
                </para>
                <para>
                    The ISR at forth level is a RAM based table much
                    like the low level interrupt table of the execution
                    tokens associated with the interrupt number.
                </para>
                <para>
                    Interrupts from hardware sources (such as the usart)
                    may not work as expected. The reason is that the
                    interrupt source is not cleared within the generic
                    ISR. This leads to an immediate re-interrupt when
                    the ISR is left. There is currently no solution but
                    a custom ISR that clears the interrupt source and
                    calls the main ISR. This code has to be run within
                    the interrupt and cannot be (easily) turned into
                    forth code, since the forth inner interpreter is not
                    reentrant.
                    <!-- maybe run an forth
                        interpreter in background to handle interrupts? -->
                </para>
            </sect2>
            <sect2 id="MULTITASKING">
                <title>Multitasking</title>
                <para>
                    amforth does not implement multitasking directly. It
                    only provides the basic functions. Within IO words
                    the deferred word
                    <command>PAUSE</command>
                    is called whenever possible. This word is
                    initialized to do nothing (
                    <command>NOOP</command>
                    ).
                </para>
            </sect2>
            <sect2 id="EXCEPTIONS">
                <title>Exception Handling</title>
                <para>
                    amforth implements the
                    <command>CATCH</command>
                    and
                    <command>THROW</command>
                    exception handling. The outermost catch frame is
                    located at the interpreter level in the word
                    <command>QUIT</command>
                    . If an exception with the value -1 or -2 is thrown,
                    <command>QUIT</command>
                    will print a message and re-start itself. Other
                    values silently restart
                    <command>QUIT</command>
                    .
                </para>
            </sect2>
            <sect2 id="USERAREA">
                <title>User Area</title>
                <para>
                    The User Area is a special RAM storage area. It
                    contains the USER variables and the User deferred
                    definitions. Access is based upon the value of the
                    user pointer UP. It can be changed with the word
                    <command>UP!</command>
                    and read with
                    <command>UP@</command>
                    . The UP itself is stored in a register pair.
                </para>
                <para>
                    The size of the user area is defined at compile time
                    in the device definition section. This may change in
                    future versions.
                </para>
		
		<para>
		    The first USER area is located at the first heap address
		    (usually RAMSTART).
		</para>
				<table>
					<title>USER Area</title>
					<tgroup cols="2">
						<thead>
							<row>
								<entry>Addressoffset (bytes)</entry>
								<entry>Purpose</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry>0</entry>
								<entry>Multitasker Status</entry>
							</row>
							<row>
								<entry>2</entry>
								<entry>Multitasker Follower</entry>
							</row>
							<row>
								<entry>4</entry>
								<entry>RP0</entry>
							</row>
							<row>
								<entry>6</entry>
								<entry>SP0</entry>
							</row>
							<row>
								<entry>8</entry>
								<entry>SP</entry>
							</row>
							<row>
								<entry>10</entry>
								<entry>HANDLER (exception handling)</entry>
							</row>
							<row>
								<entry>12</entry>
								<entry>BASE (number conversion)</entry>
							</row>
							<row>
								<entry>14</entry>
								<entry>EMIT (character IO)</entry>
							</row>

							<row>
								<entry>16</entry>
								<entry>EMIT? (character IO)</entry>
							</row>
							<row>
								<entry>18</entry>
								<entry>KEY</entry>
							</row>
							<row>
								<entry>20</entry>
								<entry>KEY?</entry>
							</row>
							<row>
								<entry>22</entry>
								<entry>/KEY</entry>
							</row>

						</tbody>
					</tgroup>
				</table>
		<para>
		
		</para>
                <para>
                    The User Area is used to provide task local
                    information. Without an active multitasker it
                    contains the starting values for the stackpointers,
                    the deferred words for terminal IO, the BASE
                    variable and the exception handler.
                </para>
                <para>
                    The multitasker uses the first 2 cells to store the
                    status and the link to the next entry in the task
                    list. In that situation the user area is/can be seen
                    as the task control block.
                </para>
            </sect2>
        </sect1>
        <sect1 id="Memory_Layout">
            <title>Memory Layout</title>
            <sect2 id="ML_FLASH">
                <title>Flash</title>
                <para>
                    The flash memory is divided into 5 sections. The
                    first section, starting at address 0, contains the
                    interrupt vector table for the low level interrupt
                    handling and a character string with the name of the
                    controller in plain text.
                </para>
                <para>
                    The next section is the initialization code block.
                    It is executed whenever the controller starts. The
                    code sets up the basic infrastructure for the forth
                    interpreter. This step is finished by calling the
                    forth interpreter with the word
                    <command>COLD</command>
                    as the entry word.
                </para>
                <para>
                    The 3rd section contains the low level interrupt
                    handling routines. The interrupt handler is very
                    closely tied to the inner interpreter. It is located
                    near the first section to use the faster relative
                    jump instructions.
                </para>
                <para>
                    The 4th section is the first part of the dictionary.
                    Nearly all colon words are located here. New words
                    are appended to this section. This section is filled
                    with FFFF cells when flashing the controller
                    initially.
                </para>
                <para>
                    The last section is identical to the boot loader
                    section of the ATmegas. It is also known as the NRWW
                    area. Here is the heart of amforth: The inner
                    interpreter and most of the words coded in assembly
                    language.
                </para>
            <para>
                <figure>
                <title>FLASH Structure Overview</title>
                <mediaobject>
                    <imageobject>
                    <imagedata fileref="flash-structure.png" format="PNG" scale="33"/>
                    </imageobject>
                    <imageobject>
                    <imagedata fileref="flash-structure.eps" format="EPS" scale="33"/>
                    </imageobject>
                </mediaobject><!--  <mediaobject>
                    <imageobject>                    
                    <imagedata fileref="flash2-structure.eps" format="EPS" scale="33"/>
                    </imageobject>
                </mediaobject> -->
                </figure>
                </para>
                <para>
                    The reason for this split is a technical one: to
                    work with a dictionary in flash the controller needs
                    to write to the flash. The ATmega architecture
                    provides a mechanism called self-programming by
                    using a special instruction and a rather complex
                    algorithm. This instruction only works in the boot
                    loader/NRWW section. amforth uses this instruction
                    in the word I!. Due to the fact that the self
                    programming is a lot more then only a simple
                    instruction, amforth needs most of the forth core
                    system to achieve it. A side effect is that amforth
                    cannot co-exist with classic bootloaders. If a
                    particular boot loader provides an API to enable
                    applications to call the flash write operation,
                    amforth can be restructured to use it. Currently
                    only very few and seldom used bootloaders exist that
                    enable this feature.
                </para>
                <para>
                    Atmegas can have more than 64 KB Flash. This
                    requires more than a 16 bit address, which is more
                    than the cell size. For one type of those bigger
                    atmegas there will be an solution with 16 bit cell
                    size: Atmega128 Controllers. They can use the whole
                    address range with an interpretation trick: The flash
                    addresses are in fact not byte addresses but word
                    addresses. Since amforth does not deal with bytes
                    but cells it is possible to use the whole address
                    range with a 16 bit cell. The Atmegas with 128
                    KBytes Flash operate slightly slower since the
                    address interpretation needs more code to access the
                    flash (both read and write). The source code uses
                    assembly macros to hide the differences.
                </para>
                <para>
                An alternative approach to place the elements in the flash shows picture
                . Here all code goes into the RWW section. This layout definitly needs a
                routine in the NRWW section that provides a cell level flash write functionality.
                The usual bootloaders do not have such an runtime accessible API, only the 
                DFU bootloader from atmel found on some USB enabled controllers does.
                <figure>
                <title>Alternative FLASH Structure</title>
                <mediaobject>
                    <imageobject>
                    <imagedata fileref="flash2-structure.png" format="PNG" scale="33"/>
                    </imageobject>
                    <imageobject>
                    <imagedata fileref="flash2-structure.eps" format="EPS" scale="33"/>
                    </imageobject>
                </mediaobject>
                </figure>
                The unused flash area beyond 0x1FFFF is not directly accessible for amforth.
                It could be used as a block device. 
                </para>
                
                <sect3>
                    <title>Flash Write</title>
                    <para>
                        The word performing the actual flash write
                        operation is
                        <command>I!</command>
                        (i-store). This word takes the value and the
                        address of a single cell to be written to flash
                        from the data stack. The address is a word
                        address, not a byte address!
                    </para>
                    <para>
                        The flash write strategy follows Atmel's
                        appnotes. The first step is turning off all
                        interrupts. Then the affected flash page is read
                        into the flash page buffer. While doing the
                        copying a check is performed whether a flash
                        erase cycle is needed. The flash erase can be
                        avoided if no bit is turned from 0 to 1. Only if
                        a bit is switched from 0 to 1 must a flash page
                        erase operation be done. In the fourth step the
                        new flash data is written and the flash is set
                        back to normal operation and the interrupt flag
                        is restored. The whole process takes a few
                        milliseconds.
                    </para>
                    <para>
                        This write strategy ensures that the flash has
                        minimal flash erase cycles while extending the
                        dictionary. In addition it keeps the forth
                        system simple since it does not need to deal
                        with page sizes or RAM based buffers for
                        dictionary operations.
                    </para>
                </sect3>
            </sect2>
            <sect2 id="ML_EEPROM">
                <title>EEPROM</title>
                <para>
                    The built-in EEPROM contains vital dictionary
                    pointer and other persistent data. They need only a
                    few EEPROM cells. The remaining space is available
                    for user programs. The easiest way to use EEPROM is
                    the use of forth VALUEs. There intended design
                    pattern (read often, write seldom) is like that for
                    the typical EEPROM usage.
                </para>
                <para>
                    Another use for EEPROM cells is to hold execution
                    tokens. The default system uses this for the turnkey
                    vector. This is an EEPROM variable that reads and
                    executes the XT at runtime. It is based on the
                    DEFER/IS standard. To define a deferred word in the
                    EEPROM use the Edefer defintion word. The standard
                    word IS is used to put a new XT into it.
                </para>
                <para>
                    Low level space management is done through the the
                    EDP variable. This is not a forth value but a EEPROM
                    based variable. To read the current value an
                    <command>e@</command>
                    operation must be used, changes are written back
                    with
                    <command>e!</command>
                    . It contains the highest EEPROM address currently
                    allocated. The name is based on the DP variable,
                    which points to the highest dictionary address.
                </para>
            </sect2>
            <sect2 id="ML_RAM">
                <title>RAM</title>
                <para>
                    The RAM address space is divided into three
                    sections: the first 32 addresses are the CPU
                    registers. Above come the IO registers and extended
                    IO registers and finally the RAM itself.
                </para>
                <para>
                    amforth needs very little RAM space for its
                    internal data structures. The biggest part are the
                    buffers for the terminal IO. In general RAM is managed
                    with the words <command>VARIABLE</command> and
                    <command>ALLOT</command>. 
                </para>
                <para>
                <xref linkend="RAM_FIGURE"/> shows an ram layout that can be used on systems
                without external RAM. All elements are located within the internal
                memory pool.
                <figure id="RAM_FIGURE">
                <title>RAM Structure Overview</title>
                <mediaobject>
                    <imageobject>
                    <imagedata fileref="ram-structure.png" format="PNG" scale="33"/>
                    </imageobject>
                    <imageobject>
                    <imagedata fileref="ram-structure.eps" format="EPS" scale="33"/>
                    </imageobject>
                </mediaobject>
                </figure>
                Another layout, that makes the external RAM easily available is shown in
                <xref linkend="RAM2_FIGURE"/>. Here are the stacks at the beginning of the internal RAM and the
                heap and all other buffers grow directly into the external data space. From
                an application point of view there is not difference but a speed penalty when
                working with external RAM instead of internal.
                <figure id="RAM2_FIGURE">
                <title>RAM Structure Overview</title>
                <mediaobject>
                    <imageobject>
                    <imagedata fileref="ram2-structure.png" format="PNG" scale="33"/>
                    </imageobject>
                    <imageobject>
                    <imagedata fileref="ram2-structure.eps" format="EPS" scale="33"/>
                    </imageobject>
                </mediaobject>
                </figure>
                
                </para>
                <para>
                    With amforth all three sections can be accessed
                    using their RAM addresses. That makes it quite easy
                    to work with words like
                    <command>C@</command>
                    . The word
                    <command>!</command>
                    implements a LSB byte order: The lower part of the
                    cell is stored at the lower address.
                </para>
                <para>
                    For the RAM there is the word
                    <command>Rdefer</command>
                    which defines a deferred word, placed in RAM. As a
                    special case there is the word
                    <command>Udefer</command>
                    , which sets up a deferred word in the user area. To
                    put an XT into them the word
                    <command>IS</command>
                    is used. This word is smart enough to distinguish
                    between the various Xdefer definitions.
                </para>
            </sect2>
        </sect1>
    </chapter>
    <chapter id="Implementation">
        <title>Implementation</title>
        <sect1 id="ANS">
            <title>ANS Words</title>
            <para>
            amforth is not fully ANS94 compatible. The main difference comes from
            the fact that the AVR ATmegas use a Havard architecture (separate code and
            data address space) that amforth does not hide. amforth gives full and unmodified
            access to the whole address space.  
            </para>
            <para>
                amforth implements most or all words from the ANS word
                sets CORE, CORE EXT, EXCEPTION and DOUBLE NUMBERS. The
                words from the word sets LOCALS, FILE-ACCESS and
                FLOATING-POINT are dropped completly. The others are
                partially implemented.
            </para>
            <sect2 id="ANS_CORE">
                <title>Core and Core EXT</title>
                <para>
                    From the CORE word set only the words >NUMBER, and EVALUATE are
                    missing. From the CORE EXT the words C", COMPILE, ,
                    CONVERT, EXPECT, SPAN, PICK, RESTORE-INPUT, ROLL are
                    not implemented.
                </para>
                <para>
                    The following words have non-standard behavior
                </para>
                <para>
                    words created with
                    <command>:</command>
                    are immediately visible. An earlier definition with
                    the same name will never be accessible. Work arounds
                    may be done with
                    <command>DEFER</command>
                    and
                    <command>IS</command>
                    .
                </para>
                <para>
                    Loop counters are checked on signed compares.
                </para>
            </sect2>
            <sect2 id="ANS_BLOCK">
                <title>Block</title>
                <para>
                    amforth has limited block support with I2C/TWI
                    serial eeprom chips with 2 byte addresses.
                </para>
            </sect2>
            <sect2 id="ANS_DOUBLENUMBER">
                <title>Double Number</title>
                <para>
                    Double cell numbers work as expected. Not all words
                    are implemented. Entering them directly using the
                    dot- notation does not work however.
                </para>
            </sect2>
            <sect2 id="ANS_EXCEPTION">
                <title>Exception</title>
                <para>
                    Exceptions are fully supported. The words
                    <command>ABORT</command>
                    and
                    <command>ABORT"</command>
                    use them internally.
                </para>
                <para>
                    The
                    <command>THROW</command>
                    codes -1, -2 and -13 work as specified.
                </para>
                <para>
                    The implementation is based upon a variable HANDLER
                    which holds the current return stack pointer
                    position. This variable is a USER variable.
                </para>
            </sect2>
            <sect2 id="ANS_FACILITY">
                <title>Facility</title>
                <para>
                    The basic system uses the
                    <command>KEY?</command>
                    and
                    <command>EMIT?</command>
                    words as deferred words in the USER area.
                </para>
                <para>
                    The word
                    <command>MS</command>
                    can implemented with the word
                    <command>1MS</command>
                    which busy waits almost exactly 1 millisecond. The
                    calculation is based upon the frequency specified at
                    compile time.
                </para>
                <para>
                    The words
                    <command>TIME&amp;DATE</command>
                    ,
                    <command>EKEY</command>
                    ,
                    <command>EKEY>CHAR</command>
                    are not implemented.
                </para>
                <para>
                    To control a VT100 terminal the words
                    <command>AT-XY</command>
                    and
                    <command>PAGE</command>
                    are written in forth code. They emit the ANSI
                    control codes according to the VT100 terminal codes.
                </para>
            </sect2>
            <sect2 id="ANS_FILEACCESS">
                <title>File Access</title>
                <para>
                    amforth does not have filesystem support. It does
                    not contain any words from this word set.
                </para>
            </sect2>
            <sect2 id="ANS_FLOATINGPOINT">
                <title>Floating Point</title>
                <para>
                    amforth does not currently support floating point
                    numbers.
                </para>
            </sect2>
            <sect2 id="ANS_LOCALS">
                <title>Locals</title>
                <para>amforth does not currently support locals.</para>
            </sect2>
            <sect2 id="ANS_MEMORY">
                <title>Memory Allocation</title>
                <para>
                    amforth does not support the words from the memory
                    allocation word set.
                </para>
            </sect2>
            <sect2 id="ANS_PROGRAMMING">
                <title>Programming Tools</title>
                <para>
                    Variants of the words
                    <command>.S</command>
                    ,
                    <command>?</command>
                    and
                    <command>DUMP</command>
                    are implemented or can easily be done. The word
                    <command>SEE</command>
                    won't be supported since amforth highly uses the
                    optimization strategy to strip forth headers
                    whenever possible. The other reason for dropping
                    <command>SEE</command>
                    is that amforth is OpenSource software. If your
                    vendor does not disclose the full source, let me
                    know. He violates the GPL.
                </para>
                <para>
                    <command>STATE</command>
                    works as specified.
                </para>
                <para>
                    The word
                    <command>WORDS</command>
                    does not sort the word list and does not take care
                    of screen sizes.
                </para>
                <para>
                    The words
                    <command>;CODE</command>
                    and
                    <command>ASSEMBLER</command>
                    are not supported. amforth has a loadable assembler
                    which can be used with the words
                    <command>CODE</command>
                    and
                    <command>END-CODE</command>
                    .
                </para>
                <para>
                    <command>CS-ROLL</command>
                    ,
                    <command>CS-PICK</command>
                    and
                    <command>AHEAD</command>
                    are not implemented. The compiler words operate with
                    the more traditional
                    <command>MARK</command>
                    /
                    <command>RESOLVE</command>
                    word pairs.
                </para>
                <para>
                    <command>FORGET</command>
                    is implemented but does not fully reset the
                    dictionary state. The better way is using
                    <command>MARKER</command>
                    from the library.
                </para>
                <para>An EDITOR is not implemented.</para>
                <para>
                    <command>[IF]</command>
                    ,
                    <command>[ELSE]</command>
                    and
                    <command>[THEN]</command>
                    are not implemented.
                </para>
            </sect2>
            <sect2 id="ANS_SEARCH">
                <title>Search Order</title>
                <para>
                    amforth does not support word lists, so no words
                    from the search word set are implemented.
                </para>
            </sect2>
            <sect2 id="ANS_STRING">
                <title>Strings</title>
                <para>
                    <command>SLITERAL</command>
                    ,
                    <command>CMOVE></command>
                    and
                    <command>/STRING</command>
                    are implemented.
                </para>
                <para>
                    <command>-TRAILING</command>
                    ,
                    <command>BLANK</command>
                    ,
                    <command>CMOVE</command>
                    ,
                    <command>COMPARE</command>
                    and
                    <command>SEARCH</command>
                    are not implemented.
                </para>
            </sect2>
        </sect1>
        <sect1 id="AMFORTH">
            <title>Amforth</title>
            <sect2 id="Startup"><title>Startup</title>
            <para>The startup code is in the file <filename>amforth.asm</filename>.
            The program execution starts at address 0. Since there is
            the interrupt service address table, the first instruction is a 
            jump to the startup code which is located right after the ISR table. 
            </para>
            <para>The assembly part of the startup code creates the basic runtime environment
            to start the virtual forth machine. It sets up the stack pointers (and
            the user pointer and places the forth instruction pointer on the 
            word <code>cold</code>. Then it activates the forth virtual machine 
            by jumping to the inner interpreter.
            </para>
            <para>The start addresses of the stacks are placed to the user area 
            for later use as well.</para>
            <sect3 id="COLD"><title>COLD</title>
            <para>The word <code>COLD</code> is the high level part of the 
            forth VM initialization. When called from
            within forth it is the equivalent to a RESET. 
            <code>COLD</code> initializes the <code>PAUSE</code> 
            deferred word to do nothing, sets the number base to hexadecimal, 
            calls the application defined <code>TURNKEY</code> action and
            finally calls <code>QUIT</code>.
            </para>
            </sect3>
            <sect3 id="TURNKEY"><title>TURNKEY</title>
            <para>The <code>turnkey</code> is a EEPROM deferred word that 
            points to an application specific startup action.
            </para>
            <para>Its main task is to initialize the character IO to enable 
            the forth interpreter to interact with the command prompt. The 
            examples shipped with amforth do this by "opening" the serial 
            port and setting up the character IO deferred words 
            (KEY, EMIT etc).
            </para>
            </sect3>
            <sect3 id="QUIT"><title>QUIT</title>
            <para>QUIT repeats the initialization of the stack pointers by reading
            them from the user area and enters the traditional ACCEPT -- INTERPRET 
            loop that never ends. </para>
            </sect3>
            </sect2>
            <sect2 id="AMFORTH_MCU">
                <title>MCU Access</title>
                <para>
                    amforth provides wrapper words for the
                    microcontroller instructions
                    <command>SLEEP</command>
                    and
                    <command>WDR</command>
                    (watch dog reset). To work properly, the MCU needs
                    more configuration. amforth itself does not call
                    these words.
                </para>
                <para>
                    Microcontrollers supporting the JTAG interface can
                    be programmed to turn off JTAG at runtime. Similiar
                    the watch dog timer can be disabled. Since both
                    actions require strict timing they need to be
                    implemented as primitives:
                    <command>-JTAG</command>
                    and
                    <command>-WDT</command>
                    .
                </para>
            </sect2>
	    
	    <sect2 id="AMFORTH_ASSEMBLER">
	       <title>Assembler</title>
	       <para>Lubos Pekny has written an assembler for amforth. To support it, amforth
	       provides the two words <code>CODE</code> and <code>END-CODE</code>. The first
	       creates a dictionary entry and sets the code field to the data filed address. The
	       interpreter will thus jump directly into the data field assuming some machine
	       code there. The word <code>END-CODE</code> places a <code>JUMP NEXT</code> into
	       the data field. This finishes the machine instruction execution and jumps back
	       to the forth interpreter.</para>
	    </sect2>
            <sect2 id="AMFORTH_MEMORY">
                <title>Memory</title>
                <para>
                    Atmega microcontroller have three different types of
                    memory. RAM, EEPROM and Flash. The words
                    <command>@</command>
                    and
                    <command>!</command>
                    work on the RAM address space (which includes IO
                    Ports and the CPU register), the words
                    <command>e@</command>
                    and
                    <command>e!</command>
                    operate on the EEPROM and
                    <command>i@</command>
                    and
                    <command>i!</command>
                    deal with the flash memory. All these words transfer
                    one cell (2 bytes) between the memory and the data
                    stack. The address is always the native address of
                    the target storage: byte-based for EEPROM and RAM,
                    word-based for flash. Therefore the flash addresses
                    64KWords or 128 KBytes address space.
                </para>
                <para>
                    External RAM shares the normal RAM address space
                    after initialization (which can be done in the
                    turnkey action). It is accessible without further
                    action.
                </para>
                <para>
                    For RAM only there is the special word pair
                    <command>c@</command>
                    /
                    <command>c!</command>
                    which operate with the lower half of a stack cell.
                    The upper byte is either ignored or set to 0 (zero).
                </para>
                <para>
                    All other types of external memory need special
                    handling, which may be masked with the block word
                    set.
                </para>
            </sect2>
            <sect2 id="AMFORTH_IO">
                <title>Input Output</title>
                <para>
                    amforth uses simple terminal IO. A serial console is
                    used. All IO is based upon the standard words
                    <command>EMIT</command>
                    /
                    <command>EMIT?</command>
                    and
                    <command>KEY</command>
                    /
                    <command>KEY?</command>
                    . In addition the word
                    <command>/KEY</command>
                    is used to signal the sender to stop. All these
                    words are deferred words in the USER area and can be
                    changed with the
                    <command>IS</command>
                    command.
                </para>
                <para>
                    The predefined words use an interrupt driven IO with
                    a buffer for input and output. They do not implement
                    a handshake procedure (XON/XOFF or CTS/RTS). The
                    default terminal device is USART0 (if more than one
                    USART port is available).
                </para>
                <para>
                    These basic words include a call to the
                    <command>PAUSE</command>
                    command to enable the use of multitasking.
                </para>
                <para>
                    Other IO depend on the hardware connected to the
                    microcontroller. Code exists to use LCD and TV
                    devices. CAN, USB or I2C are possible as well.
                    Another use of the redirect feature is the
                    following: consider some input data in external
                    EEPROM (or SD-Cards). To read it, the words
                    <command>KEY</command>
                    and
                    <command>KEY?</command>
                    can be redirected to fetch the data from them.
                </para>
            </sect2>
            <sect2 id="AMFORTH_STRING">
                <title>Strings</title>
                <para>
                    Strings can be stored in two areas: RAM and FLASH.
                    It is not possible to distinguish between the
                    storage areas based on the addresses found on the
                    data stack, it's up to the developer to keep track.
                </para>
                <para>
                    Strings are stored as counted strings with a 16 bit
		    counter value (1 flash cell)
                    Strings in flash are compressed: two consecutive
                    bytes are placed into one flash cell. The standard
                    word
                    <command>S"</command>
                    copies the string from the RAM into flash using the
                    word
                    <command>S,</command>
                    .
                </para>
            </sect2>
        </sect1>
    </chapter>
    <chapter id="Library">
        <title>Library</title>
        <para>
            Amforth does not have a formal library concept. Amforth has
            a lot of forth code that can be seen as a library of words
            and commands.
        </para>
        <sect1 id="Hardware_Access">
            <title>Hardware Access</title>
            <para>
                In the
                <filename>device/</filename>
                subdirectory are the controller specific register
                definitions. They are taken directly from the appnotes
                from Atmel. The register names are all uppercase. It is
                recommended to extract only the needed definitions since
                the whole list occupy a lot of flash memory.
            </para>
            <para>
                Some commonly used lowlevel words can be included with
                the
                <filename>dict_mcu.inc</filename>
                include file at compile time.
            </para>
        </sect1>
        <sect1 id="Modules">
            <title>Software Modules</title>
            <sect2 id="Multitasking">
                <title>Multitasking</title>
                <para>
                    The Library contains a cooperative multitasker in
                    the file
                    <filename>multitask.frt</filename>
                    . It defines a command
                    <command>multitaskpause</command>
                    which can assigned to
                    <command>pause</command>
                    :
                    <code>' multitaskpause is pause</code>
                </para>
                <para>
                    The multitasker has the following commands
                    <variablelist>
                        <varlistentry>
                            <term>
                                <cmdsynopsis>
                                    <command>onlytask</command>
                                    <arg choice="plain">(--)</arg>
                                </cmdsynopsis>
                            </term>
                            <listitem>
                                <para>
                                    Initialize the task system. The
                                    current task is placed as the only
                                    task in the task list.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term>
                                <cmdsynopsis>
                                    <command>alsotask</command>
                                    <arg choice="plain">(tid --)</arg>
                                </cmdsynopsis>
                            </term>
                            <listitem>
                                <para>
                                    Append a newly created task to the
                                    task list. A running multitasker is
                                    temporarily stopped. Make sure that
                                    the status of the task is sleep.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term>
                                <cmdsynopsis>
                                    <command>task</command>
                                    <arg choice="plain">
                                        ( dstacksize rstacksize -- tid )
                                    </arg>
                                </cmdsynopsis>
                            </term>
                            <listitem>
                                <para>
                                    Allocate RAM for the task control
                                    block (aka user area) and the two
                                    stacks. Initializes the whole user
                                    area to direct IO to the serial
                                    line. The task has still no code
                                    associated and is not inserted to
                                    the task list.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term>
                                <cmdsynopsis>
                                    <command>task-sleep</command>
                                    <arg choice="plain">( tid --)</arg>
                                </cmdsynopsis>
                            </term>
                            <listitem>
                                <para>
                                    Let the (other) task sleep. The task
                                    switcher skips the task on the next
                                    round. When a task executes this
                                    command for itself, the task
                                    continues until the next call of
                                    <command>pause</command>
                                    .
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term>
                                <cmdsynopsis>
                                    <command>task-awake</command>
                                    <arg choice="plain">( tid --)</arg>
                                </cmdsynopsis>
                            </term>
                            <listitem>
                                <para>
                                    The task is put into runnable mode.
                                    It is not activated immediately.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term>
                                <cmdsynopsis>
                                    <command>activate</command>
                                    <arg choice="plain">( tid --)</arg>
                                </cmdsynopsis>
                            </term>
                            <listitem>
                                <para>
                                    Skip all of the remaining code in
                                    the current colon word and continue
                                    the skipped code as task when the
                                    task list entry is reached by the
                                    multitasker.
                                </para>
                            </listitem>
                        </varlistentry>
                    </variablelist>
                </para>
                <para>
                    It is possible to use a timer interrupt to call the
                    command
                    <command>pause</command>
                    and turn the cooperative multitasker into a
                    preemptive one. The latency is in the worst case
                    that of the longest running uninterruptable forth
                    commands:
                    <command>1ms</command>
                    ,
                    <command>e!</command>
                    and
                    <command>i!</command>
                    . For a preemptive task switcher a lot more tools
                    like semaphores may be needed.
                </para>
            </sect2>
            <sect2 id="TWI_I2C">
                <title>TWI / I2C</title>
                <para>
                    The file
                    <filename>twi.frt</filename>
                    contains the basic words to operate with the
                    hardware TWI module of the microcontroller. The file
                    <filename>twi-eeprom.frt</filename>
                    uses these words to implement a native block buffer
                    access for I2C EEPROMs with 2byte addresses.
                </para>
                <para>
                    The word
                    <command>+twi</command>
                    initializes the TWI hardware module with the
                    supplied parameters.
                    <command>-twi</command>
                    turns the module off. The start-stop conditions are
                    sent with the
                    <command>twi.start</command>
                    and
                    <command>twi.stop</command>
                    words. Data is transferred with the three words
                    <command>twi.tx</command>
                    for transmitting (sending) a byte,
                    <command>twi.rx</command>
                    for reading a byte (and sending an ACK signal) and
                    <command>twi.rxn</command>
                    for reading a byte and sending a NACK signal.
                </para>
                <para>
                    The command
                    <command>twi.status</command>
                    fetches the TWI status register, the command
                    <command>twi.status?</command>
                    compares the status with a predefined value and
                    throws the exception -14 if they do not match.
                </para>
                <para>
                    The command
                    <command>twi.scan</command>
                    scans the whole (7 bit) address range and prints the
                    address of any device found.
                </para>
            </sect2>
            <sect2 id="I2CEEPROM">
                <title>I2C EEPROM</title>
                <para>
                    I2C EEPROMs can be used in varios ways. The file
                    <filename>twi-eeprom.frt</filename>
                    defines words to access the EEPROM at byte address
                    level and at block level. A page is the native block
                    size of the eeprom device, that is stored in the
                    <command>VALUE</command>
                    <command>twi.ee-b/blk</command>
                    . The hardware (i2c-) device address is stored in
                    the value
                    <command>twi.ee-addr</command>
                    . Currently EEPROM devices with 2byte addresses are
                    supported.
                </para>
                <para>
                    Byte level access is done with the words
                    <command>twi.ee-c!</command>
                    and
                    <command>twi.ee-c@</command>
                    . They transfer one byte from/to the eeprom address
                    given. The stack diagram is exactly the same as for
                    the RAM
                    <command>c@</command>
                    /
                    <command>c!</command>
                    . Every store operation performes an full EEPROM
                    erase/write cycle.
                </para>
                <para>
                    To transfer more bytes the block level words can be
                    used. The transfer a whole EEPROM page to/from RAM.
                    The first page is at address 0, page 1 starts at
                    address
                    <command>twi.ee-b/blk</command>
                    .
                </para>
            </sect2>
        </sect1>
    </chapter>
    <chapter id="Tools">
        <title>Tools</title>
        <sect1 id="Tools_host">
            <title>Host</title>
            <para>
                There a few number of tools on the host side (PC) that
                are specifically written to support amforth. They are
                written in script languages like perl and python and
                should work on all major operating systems.
            </para>
            <sect2>
                <title>Documentation</title>
                <para>
                    The tool
                    <command>makerefcard</command>
                    reads the assembly files from the
                    <filename>words</filename>
                    subdirectory and creates a reference card. The
                    resulting LaTeX file needs to be processed with
                    <command>latex</command>
                    to generate a nice looking overview of all words
                    available in the amforth core system.
                </para>
                <para>
                    The command
                    <command>make-htmlwords</command>
                    creates the linked overview of all words on the
                    amforth homepage.
                </para>
            </sect2>
            <sect2 id="TOOLS_UPLOAD">
                <title>Uploader</title>
                <para>
                    To transfer forth code to the microcontroller some
                    precautions need to taken. During a flash write
                    operation all interrupts are turned off. This may
                    lead to lost characters on the serial line. One
                    solution is to send very slowly and hope that the
                    receiver gets all characters. The program
                    <command>ascii-xfer</command>
                    can do the job:
                    <cmdsynopsis>
                        <command>ascii-xfr</command>
                        <arg choice="plain">-s</arg>
                        <arg choice="plain">-c $delay_char</arg>
                        <arg choice="plain">-l $delay_line</arg>
                        <arg choice="plain">$file</arg>
                        <arg choice="plain">> $tty</arg>
                    </cmdsynopsis>
                    This works but the upload of longer files needs a
                    very long time: $delay_char can be 1 or 2 ms,
                    $delay_line around 800 ms.
                </para>
                <para>
                    Another solution is
                    <command>amforth-upload.py</command>
                    . It was initially created by user
                    <ulink url="http://pix.test.at/">
                        <citetitle>pix</citetitle>
                    </ulink>
                    . His algorithm checks for the echo of every
                    character sent to the controller. At line ends the
                    uploader waits for the ok prompt to continue with
                    the next line.
                </para>
                <para>
                    This algorithm works very fast without the risk of
                    lost characters. An extension of this script
                    provides limited library support. In the source
                    files a command
                    <cmdsynopsis>
                        <command>#include</command>
                        <arg choice="plain">filename</arg>
                    </cmdsynopsis>
                    is used to upload the content of
                    <filename>filename</filename>
                    instead of the two words. The sources will only work
                    with this uploader utility, others will trigger the
                    "word-not-found" exception on the microcontroller
                    unless they recognize the #include syntax (similar
                    to the c preprocessor).
                </para>
            </sect2>
        </sect1>
    </chapter>
    <chapter id="FINAL_REMARKS">
        <title>Final Remarks</title>
        <sect1 id="ANS94_WORDS">
            <title>More ANS94 Words</title>
            <para>
                There are a few missing words from the standard CORE
                word set. Many of them are related with string
                parameters, like <command>evaluate</command>.
                The difficulty arises from the fact, that the storage
                location of a string cannot be determined by simply
                looking at the address. A solution may be a state smart
                implementation with some helper words. If running
                interactively, these words may use RAM addresses, if
                called within a compiled word they use flash addresses.
                Not really smart however..
            </para>
            <para>
                Support for Blocks may be useful. It is not trivial to
                implement a standard 1KB block buffer on an Atmega with
                only 1KB RAM. It can be useful to deploy block sizes
                smaller than 1KB to match the native block sizes of the
                attached storage devices: serial EEPROM have e.g. 64
                bytes, SD-Cards have 512 bytes. Some rather simple code
                can be used from the library for I2C/TWI EEPROM modules
                with native block sizes.
            </para>
        </sect1>
        <sect1 id="MoreController">
            <title>More Controller Types</title>
            <para>
                amforth can run on nearly the whole range of Atmegas. The only
                limiting factor is the flash size: amforth needs ca 7 KB
                for itself and can address 128 KB. The ATmega256x may be
                supported with a change in the cell size from 2 to 3
                bytes. The other possible devices are the XMega MCU.
                ATtiny devices are not supported since they lack both
                flash size and a few instructions that amforth uses.
            </para>
        </sect1>
        <sect1 id="Contributors">
            <title>Contributors</title>
            <para>
                amforth would not be the system it now is without the
                feedback and help from its users. I would like to thank
                all of them. The following people made an outstanding
                work to improve amforth (in no particular order): Milan
                Horkel, Ullrich Hoffmann, Michael Kalus, Karl Lunt,
                Bruce Wolk, Lubos Pekny. But there are many more that
                helped by simply asking how to do some tasks.
            </para>
        </sect1>
        <sect1 id="SUPPORT">
            <title>Support</title>
            <para>
                Amforth is not a commercial software. I hesitate to call
                it a product. Since you get all the source code for the
                system, you should be able to solve all problems
                yourself. On the other side I'm more than interested in
                any use of amforth and want to know what you're doing
                with it. If you find anything strange or faulty don't
                hesitate to mail it to the
                <ulink
                    url="mailto:amforth-devel@lists.sourceforge.net">
                    mailing list
                </ulink>
                .
            </para>
        </sect1>
    </chapter>
    <!--  &REFCARD; -->
</book>
